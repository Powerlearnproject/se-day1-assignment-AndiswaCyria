[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=18344831&assignment_repo_type=AssignmentRepo)
# SE_Day1
Software Engineering Day1 Assignment

#Part 1: Introduction to Software Engineering

Explain what software engineering is and discuss its importance in the technology industry.

Software engineering is a process of designing, creating or building, and testing as well as the maintenance of software applications.It uses enineering principles as well as programming softwares to create applications that are user friendly, safe and stable and reliable to the user experience. It is important in the technology industry as it fosters a foundation for creating reliable, efficient and scalable software that helps businesses optimize operations and productivity, create and roll out smooth processes, manage their data in an effective manner, and gain a competitive edge accross sectors through tailored applications.  

Identify and describe at least three key milestones in the evolution of software engineering.

The software crisis of the 1960s and 1970s: A turning point where the conmplexitities of software systems prevailed and developments projects were affected by delays, cost overruns and unreliable software. This is where a need for reliable and a discipline approach to manage software emerged as structured programme to solve the software crisis as it has clear and modular code structures, reducing complexity and improving maintainability. 
The advent of object-oriented programme: The paradigm revolutionairised software development through allowing developers to recreate real world entities as objects, promoting code reusability, modularity, and easier maintenance through concepts like inheritance, encapsulation, and polymorphism. The ideas had been emerging since the 1960s with the development of languages like Simula and Smalltalk which brought OOP to the mainstream.
Structured programme,Agile methodologies: This marked a shift towards modular and organized code design with concepts like top-down design and structured control flow, enabling better code readability and maintainability. 

List and briefly explain the phases of the Software Development Life Cycle.

Planning: Establish the goals of the project, the budget and the timelines 
Requirements analysis: consolidating and documenting user needs and the system requirements 
Design: This includes creating high level and detailed designs of designs of software architecture and user interface 
Development: Writing code and building the software according to the design specifications.
Testing: Conducting unit testing, intergrating testing and system testing, this stage focuses on identifying and fixing bugs and ensuring that the system meets the functional or non-functional requirements 
Deployment: Release the software to production or staging environments and monitoring performance and fix deployment issues
Maintenance & Support: Provide bug fixes, security updates, and enhancements as well as monitor system performance and user feedback

Compare and contrast the Waterfall and Agile methodologies. Provide examples of scenarios where each would be appropriate.

The Waterfall model is a sequential and linear approach where development follows fixed phases: Planning, Design, Development, Testing, Deployment, and Maintenance. It requires well-defined requirements from the start, making changes difficult once development begins. Testing happens after development, and customer involvement is minimal after the initial requirements phase. This model is best suited for projects with strict regulations, such as government, banking, and medical software, where detailed documentation and predictability are essential.
An example would be Building a House:
One would need a detailed blueprint before starting, and each phase follows a strict order. Once the walls are built, making major changes (like moving a room or adding a set of stairs) is costly and difficult. This is similar to the Waterfall model, where planning is done upfront, and changes later in the process are challenging.

In contrast, the Agile model is iterative and flexible, with development occurring in cycles called sprints. Agile allows frequent changes, continuous testing, and high customer collaboration. Requirements evolve throughout the process, and working software is delivered incrementally. This model is ideal for dynamic projects, such as startups, mobile apps, and e-commerce platforms, where rapid iterations and user feedback drive improvements.
An example would be Developing a Mobile App 
Lets say a team is creating a social media app. They start with basic features like user profiles and messaging, then release a working version. Based on user feedback, they add new features like video calls and dark mode in future updates. The team continuously improves the app in short cycles, making adjustments as needed. This reflects the Agile approach, where development is flexible and user-driven.

Describe the roles and responsibilities of a Software Developer, a Quality Assurance Engineer, and a Project Manager in a software engineering team.

Software developer is responsible for writing codes and rolling out software solutions 
Quality assurance engineer is makes sure that software quality is reached by designing and executing test plans. 
Project Manager is responsible for overseeing the planning, executing and the delivery of software projects. 

Discuss the importance of Integrated Development Environments (IDEs) and Version Control Systems (VCS) in the software development process. Give examples of each.
IDEs are essential tools that streamline software development by providing features like code editing, debugging, and automation. They improve productivity by integrating multiple tools into a single interface, reducing errors and speeding up development. For example, Visual Studio Code
VCS helps developers track changes, collaborate efficiently, and manage code versions. It prevents data loss and allows teams to revert to previous versions if needed. An example would be Git,

What are some common challenges faced by software engineers? Provide strategies to overcome these challenges.

Debugging and Fixing Bugs 

Challenge: Finding and fixing bugs can be time-consuming and frustrating.
Solution: Use debugging tools in IDEs, write unit tests, and follow structured debugging techniques like logging and breakpoints.

 Keeping Up with New Technologies 

Challenge: Technology changes and evolves rapidly, making it hard to stay updated.
Solution: Follow industry blogs, take online courses, attend tech conferences, and engage in hands-on projects to practice new skills.

Security and Data Privacy Threats 

Challenge: Software is vulnerable to cyberattacks and data breaches.
Solution: Following secure coding practices, conducting regular security audits, and using encryption and authentication mechanisms would help solve this challenge.

Explain the different types of testing (unit, integration, system, and acceptance) and their importance in software quality assurance.

Unit Testing 
Tests individual components (functions, classes, or modules) in isolation.
It is important because it helps identify bugs early in development and ensures each unit works correctly before integration.

Integration Testing 
Tests interactions between multiple units or modules to check data flow and communication.
Its important as it ensures different parts of the system work together as expected.

System Testing 
Tests the entire software application as a whole, including all integrated components.
It verifies that the complete system meets the specified requirements.

Acceptance Testing 
Tests whether the software meets business needs and user expectations.
It ensures that the final product is ready for release and satisfies stakeholders.

#Part 2: Introduction to AI and Prompt Engineering


Define prompt engineering and discuss its importance in interacting with AI models.

Prompt engineering is the practice of crafting effective inputs (prompts) to guide AI models in generating accurate and relevant responses. It involves structuring queries, providing context, and refining wording to optimize AI output. Its important as this enhances the quality of the responses, it improves efficiency, controls AI behaviour and also grows it capabilities. 

Provide an example of a vague prompt and then improve it by making it clear, specific, and concise. Explain why the improved prompt is more effective.

An example of a vague prompt would "Tell me about technology" 
To attain a more clear, specific and concise response it would be "Explain the impact of artificial intelligence on the healthcare industry with real-world examples" 
This would be more specific – Instead of broadly asking about "technology," it focuses on "artificial intelligence" and its impact on a particular field  which is healthcare.
Clear Intent – The improved prompt directs the AI to provide relevant real-world examples, making the response more useful and understandable.
Concise & Focused – It eliminates ambiguity, ensuring a well-structured and informative response
